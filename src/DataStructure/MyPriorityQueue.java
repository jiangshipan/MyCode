package DataStructure;import java.util.Arrays;/** * 优先队列 ： 最大优先队列： 每次出队的都是最大的值 *          最小优先队列: 每次出队的都是最小的值 */public class MyPriorityQueue {    private int[] array;    private int size;    public MyPriorityQueue() {        //队列初始长度        array = new int[32];    }    /**     * 入队     * @param key     */    public void enQueue(int key) {        //队列长度超出范围，扩容        if (size >= array.length) {            resize();        }        array[size++] = key;        upAdjust();    }    /**     * 出队     */    public int deQueue() throws Exception {        if (size <= 0) {            throw new Exception("the queue is empty!");        }        //获取堆顶元素        int head = array[0];        //让最后一个元素移动到堆顶        array[0] = array[--size];        downAdjust();        return head;    }    /**     * 上浮     */    public void upAdjust() {        //若父节点下表为parent,则左孩子下标为 2 * parent + 1, 右孩子下标为2 * parent + 2        int childIndex = size - 1;        int parentIndex = (childIndex - 1) / 2;        //temp保存插入的叶子节点值，用于最后的赋值        int temp = array[childIndex];        while (childIndex > 0 && temp < array[parentIndex]) {            //无需交换，单向赋值即可            array[childIndex] = array[parentIndex];            childIndex = parentIndex;            parentIndex = (parentIndex - 1) / 2;        }        array[childIndex] = temp;    }    /**     * 下浮     */    public void downAdjust() {        int parentIndex = 0;        //temp保存父节点的值，用于最后赋值        int temp = array[parentIndex];        int childIndex = 2 * parentIndex + 1;        while (childIndex < size) {            //如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子            if (childIndex + 1 < size && array[childIndex + 1] < array[childIndex]) {                childIndex++;            }            //如果父节点小于任何一个孩子的值 就跳出            if (temp <= array[childIndex]) {                break;            }            //赋值            array[parentIndex] = array[childIndex];            parentIndex = childIndex;            childIndex = 2 * childIndex + 1;        }        array[parentIndex] = temp;    }    /**     * 队列扩容     */    private void resize() {        //队列容量翻倍        int newSize = this.size * 2;        this.array = Arrays.copyOf(this.array, newSize);    }    public static void main(String[] args) throws Exception {        MyPriorityQueue priorityQueue = new MyPriorityQueue();        priorityQueue.enQueue(3);        priorityQueue.enQueue(5);        priorityQueue.enQueue(10);        priorityQueue.enQueue(2);        priorityQueue.enQueue(7);        System.out.println("出队元素: " + priorityQueue.deQueue());        System.out.println("出队元素: " + priorityQueue.deQueue());    }}